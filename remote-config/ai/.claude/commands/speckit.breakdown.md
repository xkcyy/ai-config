---
description: 分析和拆分大型需求为多个独立的子需求，明确各部分内容和责任划分
---

## User Input

```text
$ARGUMENTS
```

You **MUST** consider the user input before proceeding (if not empty).

## 概述

此命令用于在 `/speckit.specify` 之前，对复杂的大型需求进行分析、梳理和拆分。目标是将一个大需求分解为多个独立、可管理的子需求，明确每个子需求的边界、责任和依赖关系。

## 执行流程

### 第 1 步：需求分析与理解

1. **加载需求信息**：

   - 如果用户提供了需求文件路径（如 spec.md），读取该文件
   - 如果用户提供了文本描述，解析用户输入
   - 如果没有提供任何信息，ERROR "请提供需求描述或需求文件路径"

2. **需求复杂度评估**：
   评估需求的复杂度，考虑以下维度：

   - **功能数量**: 需求涉及的功能点数量（User Stories 数量）
   - **系统层次**: 涉及的系统层次（前端、后端、数据库、第三方集成）
   - **技术栈跨度**: 是否跨越多个技术领域
   - **业务复杂度**: 业务逻辑的复杂程度
   - **依赖关系**: 功能间的依赖和关联程度
   - **时间跨度**: 预计实现时间（超过 1 周为复杂需求）

3. **拆分建议判断**：

   根据以下规则判断是否需要拆分：

   | 维度              | 建议拆分的阈值       | 权重 |
   | ----------------- | -------------------- | ---- |
   | User Stories 数量 | > 4 个               | 高   |
   | 系统层次          | > 2 层               | 中   |
   | 预计实现时间      | > 1 周               | 高   |
   | 功能独立性        | 存在可独立交付的模块 | 高   |
   | 业务领域          | 跨越多个业务领域     | 中   |

   **判断逻辑**：

   - 如果满足任意 1 个"高"权重条件 → 强烈建议拆分
   - 如果满足任意 2 个"中"权重条件 → 建议拆分
   - 否则 → 可直接使用 `/speckit.specify`

### 第 2 步：需求拆分设计

如果需要拆分，执行以下步骤：

1. **识别关注点分离（Separation of Concerns）**：

   按照 SOLID 原则中的单一职责原则，识别需求中的不同关注点：

   - **核心业务领域**：主要的业务功能区域
   - **技术关注点**：不同的技术层次（UI、业务逻辑、数据访问）
   - **横切关注点**：跨越多个模块的公共能力（如权限、日志、缓存）
   - **外部集成点**：与外部系统的集成
   - **用户交互点**：不同的用户交互场景

2. **定义拆分维度**：

   选择合适的拆分维度（可组合使用）：

   - **按业务领域拆分**：不同的业务功能模块（推荐优先使用）
   - **按技术层次拆分**：前端、后端、数据库等
   - **按用户角色拆分**：不同角色使用的功能
   - **按优先级拆分**：核心功能 vs 扩展功能
   - **按依赖关系拆分**：基础设施 vs 业务功能

3. **执行需求拆分**：

   为每个子需求创建结构化描述：

   ```markdown
   ## 子需求 [N]: [子需求名称]

   **需求标识**: [唯一标识，如 REQ-001]
   **拆分维度**: [业务领域/技术层次/用户角色/优先级/依赖]
   **优先级**: [P0-核心基础 / P1-主要功能 / P2-增强功能]

   ### 功能范围

   [详细描述此子需求包含的功能范围]

   - 包含的 User Stories: [列出相关的 User Story]
   - 主要功能点:
     - [功能点 1]
     - [功能点 2]

   ### 责任边界

   **此子需求负责**:

   - [明确的职责 1]
   - [明确的职责 2]

   **此子需求不负责**（明确排除）:

   - [不包含的内容 1]
   - [不包含的内容 2]

   ### 依赖关系

   - **依赖于**: [列出此子需求依赖的其他子需求]
   - **被依赖于**: [列出依赖此子需求的其他子需求]
   - **外部依赖**: [外部系统或组件]

   ### 接口定义

   **对外提供**:

   - [此子需求对外提供的接口或能力]

   **对外依赖**:

   - [此子需求需要其他子需求提供的接口或能力]

   ### 验收标准（高层次）

   - [ ] [可独立验证的标准 1]
   - [ ] [可独立验证的标准 2]

   ### 技术约束

   - [技术栈限制]
   - [性能要求]
   - [兼容性要求]

   ### 预计工作量

   - **开发时间**: [预估天数]
   - **复杂度**: [简单/中等/复杂]
   - **风险等级**: [低/中/高]

   ### 独立交付能力

   - **可独立交付**: [是/否]
   - **交付价值**: [如果独立交付，提供的业务价值]
   - **增量价值**: [此子需求在整体需求中的增量价值]
   ```

4. **依赖关系可视化**：

   创建子需求的依赖关系图：

   ```markdown
   ## 子需求依赖关系图
   ```

   [基础设施需求]
   ↓
   [核心业务需求 A] ← [核心业务需求 B]
   ↓ ↓
   [扩展功能需求 C] → [扩展功能需求 D]

   ```

   **实施建议顺序**: REQ-001 → REQ-002 → REQ-003 → REQ-004
   ```

### 第 3 步：拆分方案验证

对拆分方案进行质量验证：

1. **SOLID 原则检查**：

   - **单一职责原则 (SRP)**: 每个子需求是否只有一个变更原因？
   - **开闭原则 (OCP)**: 子需求的扩展是否不影响其他子需求？
   - **里氏替换原则 (LSP)**: 子需求的实现是否可以替换而不影响整体？
   - **接口隔离原则 (ISP)**: 子需求间的依赖接口是否最小化？
   - **依赖倒置原则 (DIP)**: 子需求是否依赖于抽象而非具体实现？

2. **拆分质量检查清单**：

   ```markdown
   ## 拆分质量检查清单

   ### 独立性检查

   - [ ] 每个子需求都有明确的功能边界
   - [ ] 每个子需求都可以独立理解和描述
   - [ ] 子需求间的依赖关系清晰且最小化
   - [ ] 没有循环依赖

   ### 完整性检查

   - [ ] 所有原始需求的功能点都被覆盖
   - [ ] 没有功能点被重复分配到多个子需求
   - [ ] 每个子需求都有明确的验收标准
   - [ ] 接口定义完整且一致

   ### 可实施性检查

   - [ ] 每个子需求的工作量在合理范围内（≤ 1 周）
   - [ ] 依赖关系可以支持并行开发
   - [ ] 有明确的实施顺序建议
   - [ ] 关键路径已识别

   ### 业务价值检查

   - [ ] 每个子需求都有明确的业务价值
   - [ ] 可以支持增量交付
   - [ ] 优先级划分合理
   - [ ] 风险识别充分
   ```

3. **输出拆分结果**：

   如果验证通过，创建拆分结果文档：

   - **文件名**: `[原需求名称]-breakdown.md`
   - **位置**: 与原需求文件同目录
   - **内容**: 包含所有子需求的详细描述、依赖关系图、检查清单

### 第 4 步：后续行动建议

根据拆分结果，提供后续行动建议：

```markdown
## 后续行动建议

### 立即行动

1. **[子需求 1 名称]** (REQ-001, 优先级: P0)

   - 执行命令: `/speckit.specify "REQ-001 的详细描述"`
   - 原因: [为什么优先实施]
   - 预期产出: [spec.md, plan.md]

2. **[子需求 2 名称]** (REQ-002, 优先级: P1)
   - 执行命令: `/speckit.specify "REQ-002 的详细描述"`
   - 等待条件: REQ-001 完成 [具体里程碑]
   - 原因: [依赖关系说明]

### 后续行动

3. **[子需求 3 名称]** (REQ-003, 优先级: P1)
   ...

### 并行开发机会

- REQ-002 和 REQ-003 可以并行开发
- REQ-004 和 REQ-005 可以并行开发

### 风险提示

- [识别出的风险点]
- [缓解措施]
```

## 输出格式

命令执行完成后，输出：

```markdown
# 需求拆分分析报告

## 原始需求摘要

- **需求名称**: [名称]
- **需求来源**: [文件路径或描述]
- **复杂度评估**: [简单/中等/复杂]
- **拆分建议**: [是/否]

## 拆分方案

- **拆分维度**: [业务领域/技术层次/...]
- **子需求数量**: [N 个]
- **预计总工作量**: [N 天]

## 子需求清单

1. [REQ-001] [子需求名称] - 优先级 P0 - [X 天]
2. [REQ-002] [子需求名称] - 优先级 P1 - [X 天]
   ...

## 依赖关系

[依赖关系图或描述]

## 实施路线图

阶段 1: [REQ-001] (基础设施)
阶段 2: [REQ-002, REQ-003] (核心功能，可并行)
阶段 3: [REQ-004] (扩展功能)

## 后续步骤

1. 审核拆分方案
2. 确认实施优先级
3. 对每个子需求执行 `/speckit.specify`

## 文件输出

- 拆分详细文档: [文件路径]
- 质量检查清单: [文件路径]
```

## 关键原则

1. **SOLID 导向**: 所有拆分都应遵循 SOLID 原则，特别是单一职责原则
2. **业务优先**: 优先按业务领域拆分，而非技术层次
3. **最小依赖**: 减少子需求间的依赖关系
4. **可独立交付**: 每个子需求应尽可能支持独立交付
5. **增量价值**: 按优先级排序，确保每次交付都有业务价值
6. **接口明确**: 清晰定义子需求间的接口边界
7. **避免过度拆分**: 不要拆分得过细，保持每个子需求的完整性

## 示例场景

### 场景 1：大型需求文件拆分

```
用户: /speckit.breakdown @specs/003-specs-002-specs/spec.md
```

系统将：

1. 读取 spec.md
2. 分析 7 个 User Stories 的复杂度
3. 建议拆分为 3-4 个子需求
4. 生成拆分方案文档

### 场景 2：自然语言描述拆分

```
用户: /speckit.breakdown 实现一个完整的电商系统，包括商品管理、订单处理、支付集成、物流跟踪、用户管理
```

系统将：

1. 识别 5 个主要功能领域
2. 建议按业务领域拆分为 5 个子需求
3. 定义子需求间的依赖关系
4. 生成实施路线图

## 注意事项

- 拆分时考虑团队规模和并行开发能力
- 保持子需求的业务完整性
- 不要机械地按技术层次拆分
- 关注子需求间的接口设计
- 预留集成测试和整体验收时间
- 文档输出使用绝对路径
- 创作人标记为 @author yuand
